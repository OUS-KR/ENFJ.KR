<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê²½ë¡œ íƒìƒ‰ê¸°</title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <style>
        #game-grid { display: grid; grid-template-columns: repeat(5, 60px); grid-template-rows: repeat(5, 60px); border: 2px solid var(--h-color); position: relative; background-color: var(--card-bg); }
        .grid-cell { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 1.5em; color: var(--h-color); }
        .grid-line { position: absolute; background-color: var(--card-border); transition: background-color 0.2s; cursor: pointer; }
        .grid-line:hover { background-color: var(--nav-link-hover); }
        .grid-line.drawn { background-color: var(--h-color); }
        .grid-line.solution { background-color: var(--success-color) !important; opacity: 0.7; }
        .grid-line.hint { background-color: var(--nav-link-hover) !important; }
        .horizontal { width: 60px; height: 4px; transform: translateY(-2px); }
        .vertical { width: 4px; height: 60px; transform: translateX(-2px); }
        #controls { margin-top: 20px; text-align: center; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        .message-box {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid var(--card-border);
            border-radius: 8px;
            text-align: center;
            background-color: var(--card-bg);
            box-shadow: 0 2px 4px var(--shadow-color);
            display: none; /* Initially hidden */
        }
    </style>
</head>
<body>
    <header class="main-nav">
        <a href="/u/tests/" class="logo">INTP.KR Tests</a>
        <div class="nav-right-section">
            <nav class="nav-links" id="nav-links">
                <div class="nav-item dropdown">
                    <button class="dropdown-toggle">ì˜¤ëŠ˜ì˜ ì½˜í…ì¸ </button>
                    <div class="dropdown-menu">
                        <a href="/u/tests/today-fortune/">ì˜¤ëŠ˜ì˜ ìš´ì„¸</a>
                        <a href="/u/tests/today-game/">ì˜¤ëŠ˜ì˜ ê²Œì„</a>
                    </div>
                </div>
                <div class="nav-item dropdown">
                    <button class="dropdown-toggle">ì •ë³´</button>
                    <div class="dropdown-menu">
                        <a href="/u/tests/info-characteristics/">íŠ¹ì§•</a>
                        <a href="/u/tests/info-careers/">ì»¤ë¦¬ì–´</a>
                        <a href="/u/tests/info-cognitive-functions/">ì¸ì§€ê¸°ëŠ¥</a>
                        <a href="/u/tests/info-subtypes/">í•˜ìœ„ìœ í˜•</a>
                        <a href="/u/tests/info-relationships/">ì¸ê°„ê´€ê³„</a>
                        <a href="/u/tests/info-misconceptions/">í”í•œ ì˜¤í•´</a>
                    </div>
                </div>
                <div class="nav-item dropdown">
                    <button class="dropdown-toggle">í…ŒìŠ¤íŠ¸</button>
                    <div class="dropdown-menu">
                        <a href="/u/tests/test-logic-quiz/">ë…¼ë¦¬ë ¥ í€´ì¦ˆ</a>
                        <a href="/u/tests/test-relationship-style/">ì—°ì•  ìŠ¤íƒ€ì¼ í…ŒìŠ¤íŠ¸</a>
                        <a href="/u/tests/test-stress-triggers/">ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸</a>
                        <a href="/u/tests/test-brain-utilization/">ë‘ë‡Œ í™œìš© í…ŒìŠ¤íŠ¸</a>
                        <a href="/u/tests/test-bingo/">ë¹™ê³  ì±Œë¦°ì§€</a>
                        <a href="/u/tests/test-empathy-quiz/">INTP ê³µê° í€´ì¦ˆ</a>
                    </div>
                </div>
                <div class="nav-item dropdown">
                    <button class="dropdown-toggle">ê²Œì„</button>
                    <div class="dropdown-menu">
                        <a href="/u/tests/game-logic-puzzle/">ë…¼ë¦¬ í¼ì¦</a>
                        <a href="/u/tests/game-strategy-simulation/">ì „ëµ ì‹œë®¬ë ˆì´ì…˜</a>
                        <a href="/u/tests/game-code-decryption/">ê¸°ì–µë ¥ ê²Œì„</a>
                        <a href="/u/tests/game-abstract-reasoning/">ì¶”ìƒì  ì‚¬ê³  ê²Œì„</a>
                        <a href="/u/tests/game-travel-planner/">ì—¬í–‰ ê³„íš ì±Œë¦°ì§€</a>
                        <a href="/u/tests/game-maze-challenge/">ë¯¸ë¡œ ì±Œë¦°ì§€</a>
                        <a href="/u/tests/game-code-breaker/">ì•”í˜¸ í•´ë…ê¸°</a>
                        <a href="/u/tests/game-pathfinder/">ê²½ë¡œ íƒìƒ‰ê¸°</a>
                    </div>
                </div>
            </nav>
            <button id="theme-switcher" class="theme-switcher">ğŸŒ™</button>
            <button id="hamburger" class="hamburger">â˜°</button>
        </div>
    </header>
    <div class="container">
        <h1>ê²½ë¡œ íƒìƒ‰ê¸° (Pathfinder)</h1>
        <p style="text-align:center;">ê²©ì ê°€ì¥ìë¦¬ë¥¼ í´ë¦­í•˜ì—¬ ì„ ì„ ê·¸ë¦¬ê³ , ëª¨ë“  ìˆ«ìë¥¼ ë§Œì¡±ì‹œí‚¤ëŠ” <strong>í•˜ë‚˜ì˜ ì—°ì†ëœ ë£¨í”„</strong>ë¥¼ ì™„ì„±í•˜ì„¸ìš”.<br>ê° ì…€ì˜ ìˆ«ìëŠ” í•´ë‹¹ ì…€ì„ ë‘˜ëŸ¬ì‹¼ ë„¤ ë³€ ì¤‘ ë£¨í”„ì˜ ì¼ë¶€ê°€ ë˜ì–´ì•¼ í•˜ëŠ” ì„ ì˜ ê°œìˆ˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.<br>ì™„ì„±ëœ ê²½ë¡œëŠ” ê°ˆë¼ì§€ê±°ë‚˜ ëŠì–´ì§€ì§€ ì•ŠëŠ” í•˜ë‚˜ì˜ ë‹«íŒ ë£¨í”„ì—¬ì•¼ í•©ë‹ˆë‹¤.</p>
        <div style="display:flex; justify-content:center; margin-top:20px;">
            <div id="game-grid"></div>
        </div>
        <div id="controls">
            <button id="validate-btn" class="btn">ë‚´ ë‹µì•ˆ ê²€ì¦</button>
            <button id="hint-btn" class="btn">íŒíŠ¸</button>
            <button id="show-solution-btn" class="btn btn-primary">ì •ë‹µ ë³´ê¸°</button>
            <button id="new-game-btn" class="btn">ìƒˆë¡œìš´ í¼ì¦</button>
        </div>
        <div id="message-container" class="message-box">
            <div id="message"></div>
        </div>
    </div>

    <script src="/assets/js/main.js" defer></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const gridContainer = document.getElementById('game-grid');
        const messageContainer = document.getElementById('message-container');
        const message = document.getElementById('message');
        const validateBtn = document.getElementById('validate-btn');
        const newGameBtn = document.getElementById('new-game-btn');
        const showSolutionBtn = document.getElementById('show-solution-btn');
        const hintBtn = document.getElementById('hint-btn');
        const size = 5;

        let puzzle;
        let solution;
        let lines = {};

        function getLineKey({r1, c1, r2, c2}) {
            r1=parseInt(r1); c1=parseInt(c1); r2=parseInt(r2); c2=parseInt(c2);
            if (r1 > r2 || (r1 === r2 && c1 > c2)) {
                return `${r2},${c2},${r1},${c1}`;
            }
            return `${r1},${c1},${r2},${c2}`;
        }

        function generatePuzzle() {
            let path, newSolution;
            const minLoopLength = 10; // ìµœì†Œ ë£¨í”„ ê¸¸ì´

            while (true) {
                const visited = new Set();
                path = [];
                newSolution = {};
                const startR = Math.floor(Math.random() * (size + 1));
                const startC = Math.floor(Math.random() * (size + 1));
                const startNode = `${startR},${startC}`;

                let r = startR, c = startC;
                visited.add(startNode);
                path.push([r, c]);

                let stuck = false;
                while (path.length > 0) {
                    const [currR, currC] = path[path.length - 1];
                    const neighbors = [];
                    // Up, Down, Left, Right
                    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    dirs.sort(() => Math.random() - 0.5); // Shuffle directions

                    let moved = false;
                    for (const [dr, dc] of dirs) {
                        const nextR = currR + dr;
                        const nextC = currC + dc;
                        const nextNode = `${nextR},${nextC}`;

                        if (nextR >= 0 && nextR <= size && nextC >= 0 && nextC <= size) {
                            if (nextR === startR && nextC === startC && path.length > 1) {
                                path.push([nextR, nextC]);
                                moved = true;
                                break;
                            }
                            if (!visited.has(nextNode)) {
                                visited.add(nextNode);
                                path.push([nextR, nextC]);
                                moved = true;
                                break;
                            }
                        }
                    }

                    if (moved && path[path.length - 1][0] === startR && path[path.length - 1][1] === startC) {
                        break; // Loop closed
                    }

                    if (!moved) { // Backtrack
                        path.pop();
                    }
                }
                
                if (path.length >= minLoopLength) {
                    const lastNode = path[path.length - 1];
                    if (lastNode && lastNode[0] === startR && lastNode[1] === startC) {
                        break; // Found a good loop
                    }
                }
            }

            for (let i = 0; i < path.length - 1; i++) {
                const [r1, c1] = path[i];
                const [r2, c2] = path[i+1];
                newSolution[getLineKey({r1, c1, r2, c2})] = true;
            }

            const newPuzzle = Array(size).fill(0).map(() => Array(size).fill(0));

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    let surroundingLines = 0;
                    if (newSolution[getLineKey({r1:r, c1:c, r2:r, c2:c+1})]) surroundingLines++;
                    if (newSolution[getLineKey({r1:r+1, c1:c, r2:r+1, c2:c+1})]) surroundingLines++;
                    if (newSolution[getLineKey({r1:r, c1:c, r2:r+1, c2:c})]) surroundingLines++;
                    if (newSolution[getLineKey({r1:r, c1:c+1, r2:r+1, c2:c+1})]) surroundingLines++;
                    newPuzzle[r][c] = surroundingLines;
                }
            }

            return { puzzle: newPuzzle, solution: newSolution };
        }

        function showMessage(text, color) {
            message.textContent = text;
            message.style.color = color;
            messageContainer.style.display = 'block';
        }

        function hideMessage() {
            message.textContent = '';
            messageContainer.style.display = 'none';
        }

        function drawGrid() {
            gridContainer.innerHTML = '';
            lines = {};
            hideMessage();
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = puzzle[r][c]; // Always show the number
                    gridContainer.appendChild(cell);
                }
            }
            for (let r = 0; r <= size; r++) {
                for (let c = 0; c <= size; c++) {
                    if (c < size) {
                        const hLine = document.createElement('div');
                        hLine.className = 'grid-line horizontal';
                        hLine.style.top = `${r * 60}px`;
                        hLine.style.left = `${c * 60}px`;
                        hLine.dataset.r1 = r; hLine.dataset.c1 = c; hLine.dataset.r2 = r; hLine.dataset.c2 = c + 1;
                        hLine.addEventListener('click', toggleLine);
                        gridContainer.appendChild(hLine);
                    }
                    if (r < size) {
                        const vLine = document.createElement('div');
                        vLine.className = 'grid-line vertical';
                        vLine.style.top = `${r * 60}px`;
                        vLine.style.left = `${c * 60}px`;
                        vLine.dataset.r1 = r; vLine.dataset.c1 = c; vLine.dataset.r2 = r + 1; vLine.dataset.c2 = c;
                        vLine.addEventListener('click', toggleLine);
                        gridContainer.appendChild(vLine);
                    }
                }
            }
        }

        function startNewGame() {
            const newPuzzleData = generatePuzzle();
            puzzle = newPuzzleData.puzzle;
            solution = newPuzzleData.solution;
            drawGrid();
        }

        function toggleLine(e) {
            hideMessage();
            const line = e.target;
            line.classList.remove('solution', 'hint');
            line.classList.toggle('drawn');
            const key = getLineKey(line.dataset);
            if (line.classList.contains('drawn')) {
                lines[key] = true;
            } else {
                delete lines[key];
            }
            checkWinCondition(); // Automatic validation
        }

        function checkWinCondition() {
            // Check if the number of drawn lines matches the solution
            if (Object.keys(lines).length !== Object.keys(solution).length) {
                return;
            }

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    let surroundingLines = 0;
                    if (lines[getLineKey({r1:r, c1:c, r2:r, c2:c+1})]) surroundingLines++;
                    if (lines[getLineKey({r1:r+1, c1:c, r2:r+1, c2:c+1})]) surroundingLines++;
                    if (lines[getLineKey({r1:r, c1:c, r2:r+1, c2:c})]) surroundingLines++;
                    if (lines[getLineKey({r1:r, c1:c+1, r2:r+1, c2:c+1})]) surroundingLines++;
                    if (surroundingLines !== puzzle[r][c]) {
                        return; // Not a solution
                    }
                }
            }

            const allLineKeys = Object.keys(lines);
            if (allLineKeys.length === 0) {
                 return;
            }
            const points = {};
            allLineKeys.forEach(key => {
                const [r1, c1, r2, c2] = key.split(',').map(Number);
                const p1Key = `${r1},${c1}`; const p2Key = `${r2},${c2}`;
                points[p1Key] = (points[p1Key] || 0) + 1;
                points[p2Key] = (points[p2Key] || 0) + 1;
            });

            for (const point in points) {
                if (points[point] !== 2) {
                    return; // Not a single loop
                }
            }
            
            showMessage('ì •ë‹µì…ë‹ˆë‹¤! ì™„ë²½í•œ ë£¨í”„ë¥¼ ì™„ì„±í–ˆìŠµë‹ˆë‹¤.', 'var(--success-color)');
        }

        function validateSolution() {
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    let surroundingLines = 0;
                    if (lines[getLineKey({r1:r, c1:c, r2:r, c2:c+1})]) surroundingLines++;
                    if (lines[getLineKey({r1:r+1, c1:c, r2:r+1, c2:c+1})]) surroundingLines++;
                    if (lines[getLineKey({r1:r, c1:c, r2:r+1, c2:c})]) surroundingLines++;
                    if (lines[getLineKey({r1:r, c1:c+1, r2:r+1, c2:c+1})]) surroundingLines++;
                    if (surroundingLines !== puzzle[r][c]) {
                        showMessage(`(${r + 1}, ${c + 1}) ì…€ì˜ íŒíŠ¸(${puzzle[r][c]})ê°€ ë§ì§€ ì•ŠìŠµë‹ˆë‹¤.`, 'var(--error-color)');
                        return;
                    }
                }
            }

            const allLineKeys = Object.keys(lines);
            if (allLineKeys.length === 0) {
                 showMessage('ì„ ì„ ë¨¼ì € ê·¸ë ¤ì£¼ì„¸ìš”.', 'var(--error-color)');
                 return;
            }
            const points = {};
            allLineKeys.forEach(key => {
                const [r1, c1, r2, c2] = key.split(',').map(Number);
                const p1Key = `${r1},${c1}`; const p2Key = `${r2},${c2}`;
                points[p1Key] = (points[p1Key] || 0) + 1;
                points[p2Key] = (points[p2Key] || 0) + 1;
            });

            for (const point in points) {
                if (points[point] !== 2) {
                    showMessage('ë£¨í”„ê°€ ì•„ë‹ˆê±°ë‚˜ ì—¬ëŸ¬ ê°œì˜ ë£¨í”„ê°€ ì¡´ì¬í•©ë‹ˆë‹¤. ëª¨ë“  ì„ ì€ 2ê°œì˜ ë‹¤ë¥¸ ì„ ê³¼ ë§Œë‚˜ì•¼ í•©ë‹ˆë‹¤.', 'var(--error-color)');
                    return;
                }
            }
            
            showMessage('ì •ë‹µì…ë‹ˆë‹¤! ì™„ë²½í•œ ë£¨í”„ë¥¼ ì™„ì„±í–ˆìŠµë‹ˆë‹¤.', 'var(--success-color)');
        }
        
        function resetLines() {
            document.querySelectorAll('.grid-line').forEach(line => {
                line.classList.remove('drawn', 'solution', 'hint');
            });
            lines = {};
        }

        function showSolution() {
            resetLines();
            for (const key in solution) {
                const [r1, c1, r2, c2] = key.split(',');
                const line = document.querySelector(`[data-r1='${r1}'][data-c1='${c1}'][data-r2='${r2}'][data-c2='${c2}']`);
                if (line) {
                    line.classList.add('drawn', 'solution');
                    lines[key] = true;
                }
            }
            showMessage('ì •ë‹µ ê²½ë¡œì…ë‹ˆë‹¤.', 'var(--h-color)');
        }

        function showHint() {
            const solutionKeys = Object.keys(solution);
            const undrawnKeys = solutionKeys.filter(key => !lines[key]);

            if (undrawnKeys.length === 0) {
                showMessage('ëª¨ë“  íŒíŠ¸ë¥¼ í™•ì¸í–ˆìŠµë‹ˆë‹¤.', 'var(--h-color)');
                return;
            }

            const randomKey = undrawnKeys[Math.floor(Math.random() * undrawnKeys.length)];
            const [r1, c1, r2, c2] = randomKey.split(',');
            const line = document.querySelector(`[data-r1='${r1}'][data-c1='${c1}'][data-r2='${r2}'][data-c2='${c2}']`);
            if (line && !line.classList.contains('drawn')) {
                line.classList.add('drawn', 'hint');
                lines[randomKey] = true;
                checkWinCondition(); // Check after hint
            }
        }

        validateBtn.addEventListener('click', validateSolution);
        newGameBtn.addEventListener('click', startNewGame);
        showSolutionBtn.addEventListener('click', showSolution);
        hintBtn.addEventListener('click', showHint);

        startNewGame();
    });
    </script>
</body>
</html>
